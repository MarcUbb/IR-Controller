<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IR-Remote: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BHT_Logo_horizontal_Anthrazit_transparent_RGB_h100pix.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IR-Remote
   &#160;<span id="projectnumber">by Marc Ubbelohde</span>
   </div>
   <div id="projectbrief">Web-Interface for IR remote controlled devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">IR-Remote Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This repository contains the software for an infrared controller, the purpose of which is to be able to control devices with an infrared interface using a smartphone.</p>
<p>In this guide you find information about following topics:</p>
<ul>
<li><a href="#software">Software</a><ol type="1">
<li><a href="#project-structure">Project Structure</a></li>
<li><a href="#using-this-repository">Using this Repository</a></li>
<li><a href="#libraries">Libraries</a></li>
<li><a href="#logical-structure">Logical Structure</a></li>
<li><a href="#programs">Programs</a></li>
</ol>
</li>
<li><a href="#hardware">Hardware</a><ol type="1">
<li><a href="#components">Components</a></li>
<li><a href="#schematic">Schematic</a></li>
</ol>
</li>
</ul>
<hr  />
<hr  />
<h1><a class="anchor" id="autotoc_md1"></a>
Software</h1>
<p>Lets talk about the software which you can find in this repository. I want to start by explaining the general structure of this projects software and list the libraries used while explaining a bit which role each of them plays. After that I will go into more detail about the logical structure of the software and explain the different parts of it. Finally I will go into more detail about the programs and how they work.</p>
<p>If you are interested in a detailed documentation of the code you can find it <a href="docs/html/index.html">here</a>.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md3"></a>
Project Structure</h2>
<p>The project is a PlatformIO project and is for the most parts structured as such. The Microcontroller I used is an ESP8266 and the software is based on the Arduino framework.</p>
<p>The project is structured as follows: </p><div class="fragment"><div class="line">IR-Controller</div>
<div class="line">├───.pio                              // PlatformIO</div>
<div class="line">|   ├───...</div>
<div class="line">├───.vscode                           // VSCode</div>
<div class="line">|   ├───...</div>
<div class="line">├───docs                              // Doxygen output</div>
<div class="line">│   ├───html</div>
<div class="line">|   |   ├───index.html                // Main Page of Code Documentation</div>
<div class="line">|   |   ├───...</div>
<div class="line">│   ├───latex</div>
<div class="line">|   ├───...</div>
<div class="line">├───examples                          // Examples (may be deleted)</div>
<div class="line">|   ├───...</div>
<div class="line">├───include                           // Header Files</div>
<div class="line">│   ├───main.h</div>
<div class="line">│   ├───base.h</div>
<div class="line">│   ├───...</div>
<div class="line">├───lib                               // Libraries</div>
<div class="line">│   ├───ArduinoJson</div>
<div class="line">|   |   ├───...</div>
<div class="line">│   ├───IRremoteESP8266</div>
<div class="line">|   |   ├───...</div>
<div class="line">│   ├───NTPClient</div>
<div class="line">|   |   ├───...</div>
<div class="line">│   ├───Regexp</div>
<div class="line">|   |   ├───...</div>
<div class="line">│   ├───WiFiManager</div>
<div class="line">|   |   ├───...</div>
<div class="line">├───src                               // Source Files</div>
<div class="line">│   ├───tests                         // Unit Tests</div>
<div class="line">│   │   ├───test_main.cpp</div>
<div class="line">│   │   ├───test_filesystem.cpp</div>
<div class="line">│   │   ├───...</div>
<div class="line">│   ├───main.cpp</div>
<div class="line">│   ├───filesystem.cpp</div>
<div class="line">│   ├───...</div>
<div class="line">├───Doxyfile                          // Doxygen Configuration</div>
<div class="line">├───platformio.ini                    // PlatformIO Configuration</div>
</div><!-- fragment --><p>As you can see the project structure is kept quiet simple and should look familiar if you already worked with PlatformIO. The only difference is that the unit tests are located in the src folder instead of the test folder. This is because out of simplicity I decided to write the tests by myself instead of using a framework like Unity.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md5"></a>
Using this Repository</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
Prerequisites</h3>
<p>To use this project you need to have PlatformIO installed. You can find the installation instructions <a href="https://docs.platformio.org/en/latest/installation.html">here</a>. You also need to have a ESP8266 Microcontroller. I used a WEMOS D1 Mini but any other ESP8266 should work as well.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Setup</h3>
<p>To setup the project you need to clone the repository and open it in PlatformIO. You should now be able to build the project and upload it to your ESP8266. The WiFiManager should start autmatically to allow you to connect to your WiFi. Alternatively you can connect via WPS by pressing first the button on your router and then the button on the UI or you switch to Access Point mode to connect directly to the ESP8266.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Testing</h3>
<p>As mentioned I wrote my own unit tests for simplicity. You can run the tests by simply uncommenting the marked lines in the <a class="el" href="main_8cpp.html" title="Main file of the program.">main.cpp</a> file. The tests are run automatically on startup directly on the device and the results are printed to the serial monitor. If they fail the execution of the program is halted.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Documentation</h3>
<p>For the detailed Code Documentation I use Doxygen. The documentation is generated by running the command <code>doxygen Doxyfile</code> in the root directory of the project. The output of the documentation is located in the docs folder. Please note that in order to generate the documentation you need to have Doxygen installed. You can find the installation instructions <a href="http://www.doxygen.nl/download.html">here</a>. If you are a Linux user you can also install doxygen by running the command <code>sudo apt-get install doxygen doxygen-doc doxygen-gui graphviz</code> in your terminal.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md11"></a>
Libraries</h2>
<p>In addition to the Arduino framwork the following libraries helped me to realize this project:</p>
<h3><a class="anchor" id="autotoc_md12"></a>
ArduinoJson</h3>
<p>ArduinoJson is a library for parsing and generating JSON. It is used to store IR-Signals, time data and other data in orderly fashion. The JSON format allowed me to easily write and read the data to and from the LittleFS (filesystem) without the use of complex string manipulation or making up my own format.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
IRremoteESP8266</h3>
<p>IRremoteESP8266 is a library for receiving and sending IR-Signals. It is used to receive IR-Signals from the IR-Receiver and to send IR-Signals to the IR-LED.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
NTPClient</h3>
<p>NTPClient is a library for getting the current time from an NTP-Server. It is exlusively used in timed programs (where a signal is sent at a specific time). It is used to initialize the time on boot.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Regexp</h3>
<p>Regexp is a library that allowed me to use regular expressions in my code. It is used to scan a user written program for the correct syntax.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
WiFiManager</h3>
<p>WiFiManager is a library that allows you to connect to a WiFi network by entering the credentials in an UI instead of hard coding them. It is used to connect to the users WiFi network. I modified the library slightly to allow the user to connect via WPS and to switch to Access Point mode.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md18"></a>
Logical Structure</h2>
<p>In this section I want to give you a high level overview of the logical structure of the software. I grouped them into different parts that I found to be the most important. I will start each section with a diagram which should explain its structure for the most part but of cause I will also axplain each part in detail.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Setup</h3>
<p>The device setup includes every step that is necessarey to reach the normal operation state which in best case will after the initial setup be the starting point after rebooting.</p>
<p>Diagram of the Setup: <img src="Setup.png" alt="Setup" class="inline"/></p>
<p>As you can see in the diagram the device can operate in 2 different modes: AP-mode or STA-mode.</p>
<p>By default the device will enter STA-mode which means that it wants to connect to a WiFi network. In order to do so the device makes use of the WiFiManager library which enables it to briefly creates an access point to which the user has to connect. The user can then enter the credentials of the WiFi network he wants to connect to. The device will then try to connect to the network. If the connection is successful the device will now operate in STA-mode. If the connection fails the device will reboot and ask you again to enter the credentials. Alternatively you can also connect to your router via WPS. In order to do so you have to press the WPS on your router and then the button on the UI. If you want to connect to the device directly without using a WiFi network you can switch to AP-mode by pressing the button in the UI.</p>
<p>In AP-mode the device creates an access point in which it operates. The user connects to the access point via smartphone or computer. The access point is password secured and the user can change the password in the UI. Finally the time has to be set manually as the device does not have an external RTC.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Signal/Program Management</h3>
<p>The Signal/Program Management includes recording signals, saving and loading signals and programs and playing signals or executing programs.</p>
<p>Diagram of the Signal/Program Management: ![Signal/Program_Management](</p>
<h3><a class="anchor" id="autotoc_md21"></a>
Webserver</h3>
<p>The webserver is responsible for the communication between the device and the user. It therfore includes receive commands from the user and displaying the current state of the device to the user.</p>
<p>Diagram of the Webserver: ![Webserver](</p>
<p>As you can see in the <a href="include/website.html">website.html</a> file the website makes heavy use of the nature of the HTML form element. Since HTML form elements automatically trigger a get request on their specific action url containing the specified data they make it very easy to send data from the website to the device. To display the current state of the device which includes saved signals and programs or if the device is in Access Point or Station mode the website sends a get request to the device each time the website is reloaded.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Time Management</h3>
<p>Time Management turned out to be more complicated than I initially thought. This is mostly due to the fact that the millis() function overflows after about 49 days and that one requirement was to be able to execute timed programs even without internet connection. Thats why I want to dedicate this section to it.</p>
<p>The time is saved in the /time.json and has following format: </p><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;hours&quot;: &lt;hh&gt;,</div>
<div class="line">    &quot;minutes&quot;: &lt;mm&gt;,</div>
<div class="line">    &quot;seconds&quot;: &lt;ss&gt;,</div>
<div class="line">    &quot;weekday&quot;: &lt;w&gt;,</div>
<div class="line">    &quot;timezone&quot;: GMT+&lt;timezone&gt;,</div>
<div class="line">    &quot;init_offset&quot;: &lt;offset&gt;,</div>
<div class="line">    &quot;last_offset&quot;: &lt;offset&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Hours, minutes and seconds dont need any explenation, weekday is saved as a number from 0 to 6 where 0 is Sunday and 6 is Saturday. The timezone is saved in seconds i. e. GMT+1 is saved as 3600. The init_offset is the offset that was used to initialize the time. The last_offset is the offset at which the last overflow check took place (this becomes important later). Lets look at the initialization and update of the time.</p>
<p>Diagram of the Time initialization and update: ![Time_Management]()</p>
<p>The time gets initialized with time from an NTP server (saved timezone is respected if no timezone is saved GMT is used). If the device is not connected to the internet the request to the NTP server will fail and by NTPClient library default the time will be initialized with millis(). If that happens the user will have to update the time manually via the web interface. If the device is in AP-mode the user updates the time completly. If the device is in STA-mode the user can only update the timezone. The rest was done automatically by the NTPClient library. Lets look at how I prevented millis() from overflowing.</p>
<p>Diagram of the millis() overflow prevention logic: ![Millis_overflow]()</p>
<p>As mentioned before the millis() funciton overflows after about 49 days. In order to prevent this in <a href="src/time_management.cpp">time_management</a> you can find the funcion check_and_update_offset at the end of the file which is called every time long waiting periods are expected to occur. The function compares the current value of millis() to the last_offset and if the current value is smaller than the last_offset it means that millis() overflowed and the time and the init_offset have to be updated. Since we wont hit exactly the moment of overflow the function now checks millis() to see how much time passed since the overflow and reinitializes the time with the current offset.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md24"></a>
Programs</h2>
<p>At the end of this section I want to give you a brief overview of the different commands that are available in the program. Before I go into detail about each command there are 4 points to consider:</p><ol type="1">
<li>Programs are executed successively,</li>
<li>each command is written in a new line,</li>
<li>empthy lines are skipped and</li>
<li>programs can be aborted by pressing the designated button on the device.</li>
</ol>
<h3><a class="anchor" id="autotoc_md25"></a>
play</h3>
<p>The play command plays a signal. The syntax is as follows:</p>
<div class="fragment"><div class="line">play &lt;signal name&gt;</div>
</div><!-- fragment --><p>It is important to not that there is a small break between sending 2 signals after each other. This is because the device is still processing the signal and so it can take up to 100ms to send the next signal.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
wait</h3>
<p>The wait command waits a specified amount of milliseconds. The syntax is as follows: </p><div class="fragment"><div class="line">wait &lt;milliseconds&gt;</div>
</div><!-- fragment --><p>It is important to note that the maximum amount of milliseconds that can be waited is 4294967295. (about 49 days)</p>
<h3><a class="anchor" id="autotoc_md27"></a>
time</h3>
<p>The time command waits until a specified time before sending a signal. The syntax is as follows: </p><div class="fragment"><div class="line">&lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; &lt;signal name&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28"></a>
day</h3>
<p>The day command is similar to the time command but it waits until a specified day and a specified time before sending the signal. The syntax is as follows: </p><div class="fragment"><div class="line">&lt;day&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; &lt;signal name&gt;</div>
</div><!-- fragment --><p>The day is writte in english and can be capitalized or not.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
skip</h3>
<p>The skip command skips a specified amount of days and can be useful in timed Programs. The syntax is as follows: </p><div class="fragment"><div class="line">skip &lt;days&gt;</div>
</div><!-- fragment --><p>Similar to the wait command the maximum amount of days that can be skipped is 49.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
loop</h3>
<p>The loop command loops the lines between the loop command and the end command a specified amount of times or infinitely often. The syntax is as follows: </p><div class="fragment"><div class="line">loop &lt;times&gt; or &quot;inf&quot;</div>
<div class="line"> </div>
<div class="line">(code to be repeated)</div>
<div class="line"> </div>
<div class="line">end</div>
</div><!-- fragment --><hr  />
<hr  />
<h1><a class="anchor" id="autotoc_md32"></a>
Hardware</h1>
<p>In this section I want to talk a bit about the inner workings of the device. I will start by giving you an overview of some of the most important components I used, why I used them and what role they play in the device. After that you will find the circuit diagram.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md34"></a>
Components</h2>
<h3><a class="anchor" id="autotoc_md35"></a>
Microcontroller (ESP8266)</h3>
<p>The ESP8266 is a cheap and powerful microcontroller that is perfect for this project. It has a lot of GPIOs, a lot of memory, lots of processing power and often comes with a build in wifi antenna. It is also very easy to program and has a lot of libraries available. The ESP8266 is also very cheap and can be bought for less than 2€. In this project I used the ESP8266-12F which comes in a small form factor and features a build in wifi antenna.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
IR-LED</h3>
<p>The nature of IR light is probably the big botleneck of this project. To make the best out of it the IR-LED has to be as powerfull and multidirectional as possible. I used the so called "WTN-3W-IR940" which is a 3W 940nm IR-LED which has a 360 degree beam angle and a 180 degree viewing angle. The IR-LED is controlled by the ESP with a logic level transistor and is equipped with a small heatsink to prevent overheating. Since the IR-LED is pulsed very quickly it can easily resist currents of more than 1A.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
IR-Receiver</h3>
<p>The TL1838 is a very cheap IR-Receiver that is trimmed to 38kHz though it is possible to decode signals with frequencies from 30 kHz up to 60kHz with this sensor. Therfore it is perfect to decode most IR-Signals. The IR-Receiver is directly connected to the Microcontroller and the output is processed by the IRremoteESP8266 library.</p>
<h3><a class="anchor" id="autotoc_md38"></a>
Power Supply</h3>
<p>The Powersupply is the last component that I want to talk about. It is the Mean Well EPS-15-3.3 which can output between 3.1V and 3.6V with a maximum current of 3A. It is a very cheap and easy to use but still solid power supply that in the end made up by far for the most space in the device.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md40"></a>
Schematic</h2>
<p>The schematic of the device is shown below. It is a very simple circuit that is easy to understand. All devices are powered by the power supply which is filtered by several condensators. The IR-LED is controlled by a n-channel transistor (IRLML6344) which is pulled down. The device features 2 push buttons and 1 on/off switch. Both the reset and stop button are pulled down. The ESP8266-12F can be programmed via a USB to serial converter (i.e. FT232RL) that has to be connected to the J1 Header Pin connector. Note that RXD has to be connected to TXD on the Serial to USB converter (and TXD to RXD). Additionally the device has to be powered by the power supply since the Serial to USB Converter is not able to power the ESP by itself. Also make sure the Serial to USB Converter is set to 3.3V.</p>
<p>Schematic: <img src="schematic.png" alt="schematic" class="inline"/></p>
<hr  />
 </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
